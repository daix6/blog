{"meta":{"title":"Shawn's Blog","subtitle":null,"description":"Articles about programming mainly.","author":"Shawn Dai","url":"http://shawndai.cn/blog"},"pages":[{"title":"关于我","date":"2017-09-13T14:15:09.724Z","updated":"2017-09-13T14:15:09.724Z","comments":true,"path":"about/index.html","permalink":"http://shawndai.cn/blog/about/index.html","excerpt":"","text":"呃。。。"},{"title":"Categories","date":"2017-09-13T14:15:09.725Z","updated":"2017-09-13T14:15:09.725Z","comments":true,"path":"categories/index.html","permalink":"http://shawndai.cn/blog/categories/index.html","excerpt":"","text":""},{"title":"Tags","date":"2017-09-13T14:15:09.738Z","updated":"2017-09-13T14:15:09.738Z","comments":true,"path":"tags/index.html","permalink":"http://shawndai.cn/blog/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"读技术周刊（一）","slug":"2017-08-11","date":"2017-08-11T05:01:40.000Z","updated":"2017-09-14T05:19:25.618Z","comments":true,"path":"posts/read-weekly-issue-1/","link":"","permalink":"http://shawndai.cn/blog/posts/read-weekly-issue-1/","excerpt":"Performance and Resilience: Stress-Testing Third Partieshttps://csswizardry.com/2017/07/performance-and-resilience-stress-testing-third-parties/ 对网页中嵌入的第三方资源（譬如字体、广告、CDN 服务等）进行性能调优与弹性容错可借助的工具： Chrome - DevTools - Performance - Bottom-Up (Group by domain)，可以看到每个 domain 下资源进行加载、解析、渲染等的耗时； Chrome - Network，对每条请求而言，右键可选择是否阻塞这条请求。通过这种方式可以看出当缺少某一项资源会对页面造成什么影响； Charles，代理工具，可修改网络带宽，可调试不同网络状况下页面的加在状况； Blackhole Server，服务器宕机的状况。WebPagetest 可模拟黑洞服务器，我们修改下 Host 就可以模拟页面依赖的资源所在的服务器宕机时页面的加载情况。对于阻塞渲染的资源（样式表与未 async / defer 的脚本），这种情况会导致页面白屏一段时间（浏览器判断超时要一点儿时间）。 通过上述工具可以发现页面存在哪些问题，然后开发者可以根据这些问题制定相应的解决方案，以避免页面在依赖的第三方资源出状况的时候失去服务。","text":"Performance and Resilience: Stress-Testing Third Partieshttps://csswizardry.com/2017/07/performance-and-resilience-stress-testing-third-parties/ 对网页中嵌入的第三方资源（譬如字体、广告、CDN 服务等）进行性能调优与弹性容错可借助的工具： Chrome - DevTools - Performance - Bottom-Up (Group by domain)，可以看到每个 domain 下资源进行加载、解析、渲染等的耗时； Chrome - Network，对每条请求而言，右键可选择是否阻塞这条请求。通过这种方式可以看出当缺少某一项资源会对页面造成什么影响； Charles，代理工具，可修改网络带宽，可调试不同网络状况下页面的加在状况； Blackhole Server，服务器宕机的状况。WebPagetest 可模拟黑洞服务器，我们修改下 Host 就可以模拟页面依赖的资源所在的服务器宕机时页面的加载情况。对于阻塞渲染的资源（样式表与未 async / defer 的脚本），这种情况会导致页面白屏一段时间（浏览器判断超时要一点儿时间）。 通过上述工具可以发现页面存在哪些问题，然后开发者可以根据这些问题制定相应的解决方案，以避免页面在依赖的第三方资源出状况的时候失去服务。 Crafting Webfont FallbacksCrafting Webfont Fallbacks 如何处理 WebFont 加载缓慢或失败导致的页面渲染缓慢： 不同浏览器对 WebFont 加载有不同的处理方式，IE / Edge 支持立刻 fallback，Chrome / Firefox / Safari（Ver &gt;= 10） 则会等待三秒，对于低版本的 Safari 与安卓浏览器则会一直等待 WebFont 的加载直到其完成才开始渲染页面。（待验证） 解决方案：动态加载字体，加载完成后再设置字体重新渲染。工具：fontfaceobserver（检测啥时候字体加载完成）、css font stack（选取系统通常支持的 fallback 字体）、font style matcher（比较 fallback 与需加载的字体之间的差异，通过设置样式尽可能地减少用户感知到的前后差异）","categories":[{"name":"读技术周刊","slug":"读技术周刊","permalink":"http://shawndai.cn/blog/categories/读技术周刊/"}],"tags":[{"name":"性能优化","slug":"性能优化","permalink":"http://shawndai.cn/blog/tags/性能优化/"},{"name":"web","slug":"web","permalink":"http://shawndai.cn/blog/tags/web/"},{"name":"web font","slug":"web-font","permalink":"http://shawndai.cn/blog/tags/web-font/"},{"name":"develop tools","slug":"develop-tools","permalink":"http://shawndai.cn/blog/tags/develop-tools/"}]},{"title":"如何判断一个单向链表是否有环？","slug":"2016-10-16","date":"2016-10-15T16:00:00.000Z","updated":"2017-09-14T03:53:03.373Z","comments":true,"path":"posts/how-to-detect-whether-a-singly-linked-list-contains-loop-or-not/","link":"","permalink":"http://shawndai.cn/blog/posts/how-to-detect-whether-a-singly-linked-list-contains-loop-or-not/","excerpt":"算法不精也不熟，最先想到的总是最笨的方法，遍历，时间复杂度为 O(n2)。 后来 Google 一番，找到了 O(n) 的解决方案，很聪明（但也有种怎么也想不出来的感觉:cry:）。这个问题还有几个相关的问题： 如何判断一个单向链表是否有环？ 若有，环的入口在何方？ 最后，环的长度与该单向链表的长度各是多少？ 借记录故，我来各自解答一番。","text":"算法不精也不熟，最先想到的总是最笨的方法，遍历，时间复杂度为 O(n2)。 后来 Google 一番，找到了 O(n) 的解决方案，很聪明（但也有种怎么也想不出来的感觉:cry:）。这个问题还有几个相关的问题： 如何判断一个单向链表是否有环？ 若有，环的入口在何方？ 最后，环的长度与该单向链表的长度各是多少？ 借记录故，我来各自解答一番。 如何判断一个单向链表是否有环一个单向链表如下，使用两个指针，一快（二倍速）一慢遍历该链表，在链表有环的情况下，它们总会相遇的。快指针总会追上慢指针，就像跑步一样。因此，若相遇，则有环；反之，快指针会跑到链表尾（null）。 环的入口 假设链表长度为 n，入口在 m 处，环长度为 L。假设目前已经过 t 次循环，快指针走过路程为 2t，慢指针走过路程为 t。很容易想到，在极限状况下（首尾相连），相遇点总是在链表起点（此时 t = n），所以总能保证相遇时 t &lt;= n，也就是慢指针尚未遍历完链表，而快指针已经绕环 r（r &gt;= 1）圈了。 根据这些相互关系，我们可以得出算式： 2t = t + Lrt = Lr 假设相遇点与碰撞点距离为 x，有： x + m = t = Lr = L * (r - 1) + Lx = L - mm = L - x 即起点至入口的距离为相遇点继续走到入口的距离。（也就是图中蓝色与青色的部分） 借助此特性，于起点与 x （相遇点）各设一个一倍速指针，它们会在 m （入口）相遇！ 环的长度与单向链表的长度找到了入口点，计算环的长度只需计算从入口点出发后第一次回到入口点的距离！ 单向链表的长度 = 起点到入口点的距离 + 环的长度 一个实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586function Node(value) &#123; this.value = value this.next = null&#125;let oList = new Node(1)let count = 1, tail = oList// 之前我想用 top = oList，但浏览器报错，说 top 已经定义过。// window 有 top / self / parent 属性，其含义暂略// 我尝试给这三者赋值，只有 top 会报错，什么鬼:joy:while (count &lt; 6) &#123; tail.next = new Node(++count) tail = tail.next&#125;tail.next = oList.next.next// 判断是否有环function isCircular(head) &#123; let slow = head, fast = head while (fast) &#123; fast = fast.next if (!fast) return false else fast = fast.next slow = slow.next if (slow === fast) return true &#125; return false&#125;// 找到入口点function getEntrance(head) &#123; let slow = head, fast = head, meet = null while (fast) &#123; fast = fast.next if (!fast) return null fast = fast.next slow = slow.next if (slow === fast) &#123; meet = slow break &#125; &#125; if (!fast) return null slow = head while (slow !== meet) &#123; slow = slow.next meet = meet.next &#125; return meet&#125;function getCircleLength(head) &#123; let entry = getEntrance(head) let iterator = entry let ret = 0 do &#123; iterator = iterator.next ret++ &#125; while (iterator !== entry) return ret&#125;function getListLength(head) &#123; let entry = getEntrance(head) let iterator = head let ret = 0 do &#123; iterator = iterator.next ret++ &#125; while (iterator !== entry) return ret + getCircleLength(head)&#125;if (isCircular(oList)) &#123; console.log(getEntrance(oList)) // Node &#123; value: 3, next: [Object] &#125; console.log(getCircleLength(oList)) // 4 console.log(getListLength(oList)) // 6&#125; 参考资料 判断单链表是否存在环及求环入口点","categories":[{"name":"自问","slug":"自问","permalink":"http://shawndai.cn/blog/categories/自问/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://shawndai.cn/blog/tags/算法/"},{"name":"数据结构","slug":"数据结构","permalink":"http://shawndai.cn/blog/tags/数据结构/"}]},{"title":"JavaScript 如何面向对象编程？","slug":"2016-08-26","date":"2016-08-25T16:00:00.000Z","updated":"2017-09-14T03:51:19.695Z","comments":true,"path":"posts/how-to-program-object-oriented-with-javascript/","link":"","permalink":"http://shawndai.cn/blog/posts/how-to-program-object-oriented-with-javascript/","excerpt":"面向对象编程（Object-Oriented Programming）是基于对象的一种编程范式（paradigm）。其有三个广为人知的特性，封装（Encapsulation）、继承（Inheritance）和多态（Polymorphism），让编程更灵活、可维护。常见的面向对象编程方式都是基于类（class）的，在 C++、Java 等高级语言中都以类的形式得到实现。 在 JavaScript（以下简称 JS）是基于对象的弱类型语言，并无类的概念，但其提供了原型机制，可用来支持面向对象编程。下面分别用 JS 实现 OOP 三大特性。","text":"面向对象编程（Object-Oriented Programming）是基于对象的一种编程范式（paradigm）。其有三个广为人知的特性，封装（Encapsulation）、继承（Inheritance）和多态（Polymorphism），让编程更灵活、可维护。常见的面向对象编程方式都是基于类（class）的，在 C++、Java 等高级语言中都以类的形式得到实现。 在 JavaScript（以下简称 JS）是基于对象的弱类型语言，并无类的概念，但其提供了原型机制，可用来支持面向对象编程。下面分别用 JS 实现 OOP 三大特性。 封装之前我一直以为封装指的是方法与数据能放在一起（类），但一看维基百科才得知，封装是一种限制外部直接访问对象内部数据与方法的语言机制。在 C++ 中，封装就是通过 public、private（和 protected） 来实现的。 JS 中并没有提供该机制，但可以借助闭包来实现私有变量与方法。 1234567891011function foo () &#123; let name = 'Hankey' this.getName = () =&gt; name; this.setName = n =&gt; &#123; name = n &#125;;&#125;let fool = new foo()fool.name // undefinedfool.getName() // Hankeyfool.setName('Mr.Hankey')fool.getName() // Mr.Hankey 继承JS 没有类这个概念，但却提供了原型链（Prototype Chain）机制，使得继承成为可能。关于原型这里且不细谈。（BTW，Self 是第一个实现原型的编程语言） 虽说都是使用原型，但不同的使用方法会形成各样的继承方式。目前最为完善的似乎就是组合寄生式继承了。 1234567891011121314151617181920function papa (name) &#123; // 被 Stranger Things 影响了 :sob: this.name = name&#125;papa.prototype.toString = function _toString () &#123; console.log('Papa is ' + this.name + '!')&#125;function baby (name, gender) &#123; papa.call(this, name) // 组合 this.gender = gender&#125;baby.prototype = Object.create(papa.prototype) // 寄生baby.prototype.constructor = baby // 修复重写原型导致的混乱baby.prototype.toString2 = function _toString2 () &#123; console.log('Baby named ' + this.name + ', is a ' + this.gender + '.');&#125;var eleven = new baby('11', 'girl')eleven.toString() // Papa is 11!eleven.toString2() // Baby named 11, is a girl. Object.create(obj, [properties]) 在做的就是创建一个原型为 obj 的对象。它实际上做的事情基本如下： 12345function create (obj) &#123; function F () &#123;&#125; F.prototype = obj return new F()&#125; 多态参考资料 Object-oriented programming Encapsulation Inheritance Prototype-based programming","categories":[{"name":"自问","slug":"自问","permalink":"http://shawndai.cn/blog/categories/自问/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://shawndai.cn/blog/tags/javascript/"},{"name":"ES6","slug":"ES6","permalink":"http://shawndai.cn/blog/tags/ES6/"}]},{"title":"何为跨域？如何跨域？","slug":"2016-08-01","date":"2016-07-31T16:00:00.000Z","updated":"2017-09-14T03:56:41.907Z","comments":true,"path":"posts/whats-cors-and-how-to-make-cors/","link":"","permalink":"http://shawndai.cn/blog/posts/whats-cors-and-how-to-make-cors/","excerpt":"（任性决定以后英文一个月中文一个月交替！:smile:） 何为跨域Web 站点众多，人心难测。当在访问未知站点时，我们无法确定其是否可信。如果该站点试图读取（譬如通过 ajax）我们在非同源站点如 gmail.com 的私人信息，这不仅侵犯了我们的隐私，同时也可能会损害我们的利益。为了避免此类安全问题的发生，用户代理（如浏览器）通常会遵循同源策略。","text":"（任性决定以后英文一个月中文一个月交替！:smile:） 何为跨域Web 站点众多，人心难测。当在访问未知站点时，我们无法确定其是否可信。如果该站点试图读取（譬如通过 ajax）我们在非同源站点如 gmail.com 的私人信息，这不仅侵犯了我们的隐私，同时也可能会损害我们的利益。为了避免此类安全问题的发生，用户代理（如浏览器）通常会遵循同源策略。 源根据 RFC6454 的定义，源（Origin）由协议（protocol）、主机（host）、端口（port）组成。对于两个 URL，当且仅当三者皆完全匹配时才被视为同源。 对于 http://www.example.com/a/b.html，同源检测结果如下表： URL 同源 理由 http://www.example.com/a/c.html 同 - http://www.example.com/b.html 同 - https://www.example.com/a/c.html 不同 协议 http://example.com/a/c.html 不同 主机 http://www.example.com:3000/a/c.html 不同 端口 同源策略对于涉及网络的 API，同源策略（Same-Origin Policy）分别处理发送与接受的请求。通常来说，一个源被允许发送信息至另一个源，但不被允许从另一个源接收信息。它阻止了恶意站点从其他站点读取机密信息，也阻止了网络内容合法地读取其他站点提供的信息。 根据 StackOverflow 上的这个答案，同源策略通常遵循以下规则： 规则#1：不允许从不同源读取任何资源 规则#2：允许写任意信息至不同源，但规则#1不允许读取响应 规则#3：允许自由发送跨域的 GET 与 POST 请求，但无法控制 HTTP 头 对于不同标签、不同 API 同源策略的规则可能会有些许不同。 例如，我之前的一篇答案中引用了维基百科的图片，虽然其能正确的显示，但我无法读取该图像的信息（除了 DOM 元素的属性）： 内嵌非同源脚本时，浏览器虽然能正确加载，但在脚本内发生的具体错误是无法显示的，只有同源脚本的错误才能被捕获。如果我试图使用 ajax 请求非同源的脚本文件时，同样地，我们无法获得该脚本的内容。以 Google Analytics 的脚本为例，ajax 无法读取响应： 在 Network 能看见发出的 ajax 请求。浏览器确实下载了文件，但由于同源策略，会阻止我们读取脚本内容： 为何跨域由于同源策略限制过于严格，但为了实现某些特定功能（或者出于性能考虑），我们需要实现合理的跨域请求。 如何跨域聪明的开发者想出了很多方法（找到了很多漏洞）来解决这个问题。 document.domain + iframe在同源策略中，存在例外情况，就是脚本（JavaScript）可以通过 document.domain 方法来改变本身的源。不过，只能设置为当前域的一个后缀（suffix）。例如，对于页面 http://baz.foo.com 来说，其 document.domain 只能设置为 foo.com。如果设置为其他的域，则会报错。在更改域之后，新的域则会作为后续同源检测的依据。注意，对 document.domain 的赋值会导致域的端口号被 null 覆盖，所以如果存在端口号，必须得加上。 利用这一特点，我们可以结合 document.domain 与 &lt;iframe&gt; 实现跨域。由于同源策略，当前页上非同源的 iframe 窗口里的内容我们是无法操作，但如果我们当前页与 iframe 窗口的域都改为相同（合法）域，则当前页与 iframe 页就能相互通信了。这样也就实现了跨域！ 一个栗子： 假设父域为 http://foo.com，子域为 http://baz.foo.com 123456789101112131415161718192021222324252627282930313233var iframe = document.createElement('iframe')// 父域 -&gt; 子域iframe.src = 'http://baz.foo.com/iframe'// 子域 -&gt; 父域iframe.src = 'http://foo.com/iframe'// 发起请求方iframe.style.display = 'none'document.body.appendChild(iframe)iframe.onload = function () &#123; document.domain = 'foo.com' // 设置为父域 function handle (data) &#123; console.log(data) &#125; function get () &#123; // 在 iframe 里创建 XHR。如果该 iframe 是非同源的窗口，下面会报错 let xhr = new iframe.contentWindow.XMLHttpRequest() xhr.onreadystatechange = function () &#123; if (xhr.readyState === 4 &amp;&amp; xhr.status === 200) handle(xhr) &#125; // 如果使用当前页的 XHR，则会因跨域报错！（该 API 并没有 domain 之说~:joy:） xhr.open('GET', 'http://baz.foo.com/api/get') xhr.send() &#125;&#125;// 接受请求方（iframe 窗口）document.domain = 'foo.com' // 也设置为父域 JSONPJSONP （JSON with Padding），是 Web 开发者用来克服浏览器跨域限制的一种 JSON 扩展。如我们所知，AJAX 虽能下载却无法读取非同源的资源，而对于外联的 &lt;script&gt; 标签，浏览器会正确的下载并执行、求值，只是用户无法读取其中内容。借助 &lt;script&gt; 标签的这一特征，我们可以通过 JSONP 拿到跨域数据。 举个栗子。假设存在一个 URL 提供 JSON 类型数据（可能动态从数据库查询），在 HTML 中插入一个链接为此的 &lt;script&gt; 标签并无法获得该处的数据，因为浏览器只把其解析为一个对象，并没有赋值或者别的什么东西。而如果使用 JSONP，&lt;script&gt; 标签 src 属性指向的那个 URL 提供的 JSON 数据必须被一段 JavaScript 代码包裹的数据。这段代码就会被浏览器解析并执行，请求方已定义的函数就能间接地获得 JSON 数据了。 （不过，使用 JSONP 也存在许多安全问题。譬如，在当前页面会注入来自某 URL 的任意内容，这会很危险…） 简易流程的请求与响应如下： 1234&lt;!-- 请求 --&gt;&lt;script type=\"application/javascript\" src=\"http://example.com/12?=handle\"&gt;&lt;/script&gt;&lt;!-- 响应 --&gt;&lt;!-- handle(&#123; username: 'shawn', status: 'OK' &#125;) --&gt; 可以在控制台跑的栗子： 1234567891011121314151617181920function cb (data) &#123; console.log(data)&#125;// http://doc.jsfiddle.net/use/echo.html#jsonpvar jsonp = 'http://jsfiddle.net/echo/jsonp/?callback=cb&amp;data=a'// Pure AJAXvar ajax = new XMLHttpRequest()ajax.onreadystatechange = function () &#123; if (ajax.readyState === 4 &amp;&amp; ajax.status === 200) console.log(ajax.responseText)&#125;ajax.open('GET', jsonp, true)ajax.send()// With JSONPvar script = document.createElement('script')script.src = jsonpdocument.body.insertBefore(script, document.body.lastElementChild) 这是在控制台测试的结果： window.postMessagewindow.postMessage 是 HTML5 引入的可控的安全的可跨域通信的 API。其语法如下： 1otherWindow.postMessage(message, targetOrigin) otherWindow：指的是被请求页面的 window 的引用，而不是当前页面 message：指的是要传输的数据，可以是任意类型 targetOrigin：指定了被请求页面的源应该满足的格式，可以是 URI（协议、主机、端口三者匹配），或者是 “*”，表示不加限制 多说不如栗子： 假设 A 站（http://acfun.com）要向 B 站（http://bilibili.com）发送一个消息，用 postMessage 该如何处理呢？ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465// acfun.comvar iframe = document.createElement('iframe')iframe.style.display = 'none'iframe.src = 'http://bilibili.com'document.appendChild(iframe)iframe.onload = function () &#123; function handle (xhr, method) &#123; if (method === 'GET') console.log(method, xhr.responseText) else if (method === 'POST') console.log(method, xhr.responseText) &#125; window.addEventListener('message', function (e) &#123; var message = e.data handle(message.xhr, method) &#125;) // GET function get () &#123; iframe.contentWindow.postMessage(&#123; method: 'GET', url: 'http://bilibili.com/api/1' &#125;, 'http://bilibili.com') &#125; // POST function post () &#123; iframe.contentWindow.postMessage(&#123; method: 'POST', url: 'http://bilibili.com/api', headers: &#123; 'Content-Type': 'application/json;charset=UTF-8' &#125;, data: JSON.stringify(&#123; id: 1 &#125;), &#125;, 'http://bilibili.com') &#125;&#125;// bilibili.comwindow.addEventListener('message', function (e) &#123; var message = e.data // 在接受到消息时就根据消息内容发送 XHR 来请求相应的数据并发回原站点 var xhr = new XMLHttpRequest() if (xhr.headers) for (var header in xhr.headers) xhr.setRequestHeader(header) xhr.onreadystatechange = function () &#123; if (xhr.readyState === 4 &amp;&amp; xhr.status === 200) // e.source 即为发送消息页的 window e.source.postMessage(&#123; method: message.method, xhr: &#123; responseText: xhr.responseText &#125; &#125;, e.origin) // e.origin 为发送消息页的 url &#125; xhr.open(message.method, message.url, true) xhr.send(message.data)&#125;) CORS前面提到的三种跨域手段，除了 postMessage，其它的看起来都有点黑魔法:sparkle:的感觉。如果能直接发请求，而不用整这些乱七八糟的东西就再好不过了。由于需求确实存在，W3C Web 工作组提出了一份新的建议标准，跨源资源共享（Cross-Origin Resource Share）。该机制能使得安全地进行跨域数据传输成为可能。该机制需要服务端的配合才可生效。 CORS 针对不同的请求有不同的处理方式，分为简单请求与非简单请求。 简单请求指的是满足以下三点的请求： 方法为 GET / HEAD / POST 除用户代理设置的头外，只设置了 Accept / Accept-Language / Content-Language / Content-Type Content-Type 是以下三种之一： application/x-www-form-urlencoded multipart/form-data text/plain 简单请求浏览器会根据 URL 自动识别 XMLHttpRequest 是否跨域，如果跨域会自动为请求头添加 Origin 字段。发送出去后，如果响应头中包含 Access-Control-Allow-Origin 字段并且其值包含 Origin 的值，浏览器则不会拦截该响应。 例如，我们对 http://freegeoip.net/json/ 发出一个 XMLHttpRequest 请求，其请求与响应如图： 如果对服务器未设置 Access-Control-Allow-Origin 响应头的发送请求，该请求会被视作跨域请求而被浏览器拦截。 携带 Cookie浏览器对 XMLHttpRequest 发起的跨域请求默认是不允许发送 Cookies（与验证信息） 的，在上图中也有体现。但如果将 XMLHttpRequest 的 withCredentials 属性置为 true，浏览器就会允许 Cookies（与验证信息）的发送。 依然对 http://freegeoip.net/json/ 发出一个 XMLHttpRequest 请求，并设置 withCredentials 为 true，其请求与响应如图： 不过要注意的是，如果服务端能够响应带 Credentials 的请求，则其允许的源必须为请求者，而不能是 “*”。 预请求对于非简单请求（不满足那三点），浏览器必须发送一个 OPTIONS 请求（预请求）给目的站点，来验证该跨域请求对目的站点来说是否可接受，以免造成安全事故。 123456789var xhr = new XMLHttpRequest()xhr.onreadystatechange = function () &#123; if (xhr.readyState === 4 &amp;&amp; xhr.status === 200) console.log(xhr.response)&#125;xhr.open('PUT', 'http://freegeoip.net/json/', true) // 非 GET/POST/HEADxhr.setRequestHeader('Content-Type', 'application/json')xhr.setRequestHeader('X-RANDOM', '123')xhr.send() 其请求与响应如图： 发现该服务并不支持非简单请求。 下面是支持非简单请求应有的响应： koa 提供了一个简单的实现方案，koa-cors。 适用场景document.domain + iframe 支持较老浏览器 支持不止于 GET 只需父、子域之间通信 JSONP 支持较老浏览器 只支持 GET 支持跨完全不同的域 window.postMessage 支持 IE8+，IE8/9 只支持在 iframes/frames 间传递消息，不支持弹出窗口；且 message 只能为字符串。:pill: 支持不止于 GET 支持跨完全不同的域 CORS (推荐) 支持 IE8+ 支持不止于 GET 支持自定义 HTTP 头 支持发送 Cookies 支持跨完全不同的域 参考文献 RFC 6454 - The Web Origin Concept W3C - Same-Origin Policy MDN - Same-Origin Policy StackOverflow - Why do browser APIs restrict cross-domain requests? StackOverflow - Ways to circumvent the same-origin policy Wikipedia - JSONP MDN - postMessage MDN - HTTP Access Control 跨域资源共享 CORS 详解 cross-domain-with-koa","categories":[{"name":"自问","slug":"自问","permalink":"http://shawndai.cn/blog/categories/自问/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://shawndai.cn/blog/tags/javascript/"},{"name":"跨域","slug":"跨域","permalink":"http://shawndai.cn/blog/tags/跨域/"},{"name":"jsonp","slug":"jsonp","permalink":"http://shawndai.cn/blog/tags/jsonp/"}]},{"title":"What's the differences between AMD, CMD, CommonJS?","slug":"2016-07-25","date":"2016-07-24T16:00:00.000Z","updated":"2017-09-14T03:50:26.262Z","comments":true,"path":"posts/whats-the-differences-between-amd-cmd-commonjs/","link":"","permalink":"http://shawndai.cn/blog/posts/whats-the-differences-between-amd-cmd-commonjs/","excerpt":"AMD (Asynchronous Module Definition)AMD is a JavaScript specification that defines an API for defining code modules and their dependencies, and loading them asynchronously if desired. The specification only defines a single function define. 1define(id, dependencies, factory);","text":"AMD (Asynchronous Module Definition)AMD is a JavaScript specification that defines an API for defining code modules and their dependencies, and loading them asynchronously if desired. The specification only defines a single function define. 1define(id, dependencies, factory); id: the module name. If not specifed, defaults to the script’s name. No relative ids. dependencies: an array of dependencies, If omitted, defaults to [‘require’, ‘exports’, ‘module’]. The dependencies must be resolved prior to the execution of the module factory function, and the resolved values should be passed as arguments to the factory function with argument position corresponding to indexes in the dependencies array. factory: a function that should be executed to instantiate the module or an object. It should only be executed once. Example: 1define('one', (require, exports, module) =&gt; () =&gt; console.log('one')) RequireJSReferences AMD RequireJS","categories":[{"name":"自问","slug":"自问","permalink":"http://shawndai.cn/blog/categories/自问/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://shawndai.cn/blog/tags/javascript/"},{"name":"模块","slug":"模块","permalink":"http://shawndai.cn/blog/tags/模块/"}]},{"title":"What's word-break and word-wrap?","slug":"2016-07-24","date":"2016-07-23T16:00:00.000Z","updated":"2017-09-14T03:50:07.335Z","comments":true,"path":"posts/whats-word-break-and-word-wrap/","link":"","permalink":"http://shawndai.cn/blog/posts/whats-word-break-and-word-wrap/","excerpt":"word-wrap - Overflow WrappingThe overflow-wrap (aka word-wrap) property specifies whether the user agent may arbitrarily break within a word to prevent overflow when an otherwise-unbreakable string is too long to fit within the line box. normal: Lines may break only at allowed break points. (Like whitespace) break-word: An unbreakable word (a complete word) may be broken at arbitrary points if there are no otherwise acceptable break points in the line.Only work when the white-space property allows wrapping.","text":"word-wrap - Overflow WrappingThe overflow-wrap (aka word-wrap) property specifies whether the user agent may arbitrarily break within a word to prevent overflow when an otherwise-unbreakable string is too long to fit within the line box. normal: Lines may break only at allowed break points. (Like whitespace) break-word: An unbreakable word (a complete word) may be broken at arbitrary points if there are no otherwise acceptable break points in the line.Only work when the white-space property allows wrapping. word-break - Breaking Rules for LettersThe word-break property specifies whether to break lines within a word. normal: Words break as usual break-all: In addition to normal, lines may break between any two letters (for non-CJK (Chinese/Japanese/Korean) text). keep-all: Don’t allow word breaks for CJK text. Non-CJK text behavior is the same as for normal. A nice example given by W3C, and this by MDN. 123normal: 什·么·鬼，·what·the·fuck.break-all: 什·么·鬼，·w·h·a·t·t·h·e·f·u·c·k.keep-all: 什么鬼，·what·the·fuck. See the Pen css text by Shawn Dai (@daix6) on CodePen. References CSS Text Module Level 3 overflow-wrap - MDN word-break - MDN","categories":[{"name":"自问","slug":"自问","permalink":"http://shawndai.cn/blog/categories/自问/"}],"tags":[{"name":"css","slug":"css","permalink":"http://shawndai.cn/blog/tags/css/"},{"name":"排版","slug":"排版","permalink":"http://shawndai.cn/blog/tags/排版/"}]},{"title":"List of Cache-Related HTTP Header Fields?","slug":"2016-07-21","date":"2016-07-20T16:00:00.000Z","updated":"2017-09-14T03:49:55.309Z","comments":true,"path":"posts/list-of-cache-related-http-header-fields/","link":"","permalink":"http://shawndai.cn/blog/posts/list-of-cache-related-http-header-fields/","excerpt":"(Personally, this answer is totally a mess :rage::rage::rage:, I may rewrite it some day…:disappointed_relieved::sob:)","text":"(Personally, this answer is totally a mess :rage::rage::rage:, I may rewrite it some day…:disappointed_relieved::sob:) Cache-Control (Response Header Mainly) What’s cacheable public: This resource is cacheable by clients and shared (proxy) cache. Better for resources that everybody can access. private: Default. Only cacheable by clients and not by shared (proxy) cache. Better for resources intended for only one user. no-cache: Do not use the cache to satisfy subsequent requests without succesful revalidation with the origin server (every time).If this directives specify field-names, the cache can be used to satisfy subsequent requests but the specified field-names should be stripped out (like cookies) without succesful revalidation with the origin server. What may be stored by caches no-store: Do not store any part of this request (or response). Designed for sensitive information requirements. The expiration mechanism max-age: Imply the response is cacheable unless other more restrictive cache directive is also present. max-age directive overrides Expires header. s-maxage: For shared cache (CDN), the maximum age specified by this directive will override max-age directive and Expires header. If this cache becomes stale, must revalidate it when respond to a subsequent request. If private, this will be ignored. Cache revalidation and reload controls must-revalidate: Revalidate the resource on any subsequent request every time and not serve stale content. proxy-revalidate: Similar to must-revalidate, except that it does not apply to non-shared user agent caches. no-transform: The cache or proxy must not change any aspect of the entity-body that is specified by these headers, including the value of the entity-body itself. Cache control extensions: Unrecognized directives will be ignored. ETag (Entity Tag)A unique identifier for the requested resource, typically the hash of the resource or the hash of the timestamp the resource was updated. It can be used to validate the entry. ExpiresThe date/time after which the response is considered stale. A stale cache entry may not normally be returned by a ache unless it’s first validated with the origin server. Last-ModifiedThe date/time at which the origin server believes the resource was last modified. If-Modified-Since (Request)If the requested variant has not been modified since the time specified in this field, an entity will not be returned from the server; instead, a 304 response will be returned without any message-body. If-Unmodified-Since works like If-Modified-Since except the condition is opposite. If-None-Match (Request)If any of the entity tags match the entity tag of the requested resource, the server should return 304. If-Match works like If-None-Match except the condition is opposite. References HTTP caching Header Field Definitions :+1: Caching in HTTP Private vs Public in Cache-Control A Beginner’s Guide to HTTP Cache Headers :+1: Cache Control Directives Demystified","categories":[{"name":"自问","slug":"自问","permalink":"http://shawndai.cn/blog/categories/自问/"}],"tags":[{"name":"http","slug":"http","permalink":"http://shawndai.cn/blog/tags/http/"},{"name":"cache","slug":"cache","permalink":"http://shawndai.cn/blog/tags/cache/"}]},{"title":"How to get nth fibonacci number in JavaScript?","slug":"2016-07-19","date":"2016-07-18T16:00:00.000Z","updated":"2017-09-14T03:49:37.928Z","comments":true,"path":"posts/how-to-get-nth-fibonacci-number-in-javascript/","link":"","permalink":"http://shawndai.cn/blog/posts/how-to-get-nth-fibonacci-number-in-javascript/","excerpt":"In mathematics, the Fibonacci numbers are the numbers in the following integer sequence, called the Fibonacci sequence: 0, 1, 1, 2, 3, 5, 8, 13, 21, 34, … By definition, the first two numbers in the Fibonacci sequence are either 1 and 1, or 0 and 1, depending on the chosen starting point of the sequence, and each subsequent number is the sum of the previous two.","text":"In mathematics, the Fibonacci numbers are the numbers in the following integer sequence, called the Fibonacci sequence: 0, 1, 1, 2, 3, 5, 8, 13, 21, 34, … By definition, the first two numbers in the Fibonacci sequence are either 1 and 1, or 0 and 1, depending on the chosen starting point of the sequence, and each subsequent number is the sum of the previous two. A simple version123456function fibonacci(n) &#123; if (n &lt; 0) throw Error('Wrong arguments! Natural numbers only!') return n &lt; 2 ? n : fibonacci(n - 1) + fibonacci(n - 2)&#125;fibonacci(50) The simplest version takes many unnecessary caculations during the process. There are many redundancy in the fibonacci(n-1) and fibonacci(n-2). This kind of recursion is called tree recursion. How about doing the recursion linearly? Linear Recursion1234567891011function fibonacci(n) &#123; if (n &lt; 0) throw Error('Wrong arguments! Natural numbers only!') else &#123; function iter(cur, next, count) &#123; if (count === 0) return cur return iter(next, cur + next, count--) &#125; return iter(0, 1, n) &#125;&#125; By this way, the recursion becames linear with O(n) time complexity. It’s much faster than the tree recursion version. The reason behind it is that it always cache the latest two result which the tree recursion does not. How about we create a Map that cache the result of n once we caculate it? Memoization1234567891011121314151617let fibonacci = (function() &#123; let memo = &#123;&#125; return function f(n) &#123; if (n &lt; 0) throw Error('Wrong arguments! Natural numbers only!') else &#123; if (n in memo) return memo[n] else &#123; let cache; if (n &lt; 2) cache = n else cache = f(n - 1) + f(n - 2) memo[n] = cache return memo[n] &#125; &#125; &#125;&#125;)() In this implementation, it caches every caculated fibonacci(n) in memo, which provides better performance than the simplest version. But it takes more spaces than the linear recursion because of the memo. All of the above implementation will throw RangeError: Maximum call stack size exceeded when n is quite big. So why don’t we try to make use of iteration? Iteration123456789function fibonacci (n) &#123; if (n &lt; 0) throw Error('Wrong arguments! Natural numbers only!') let cur = 0, next = 1 for (let i = 0; i &lt; n; i++) [cur, next] = [next, cur + next] return cur&#125; By this way, there won’t be RangeError any more! BenchmarkThere is my different implementations: fibonacci.js. The picture below shows the performance of different implementations. Have FunES6 introduced generators. Try fibonacci with generator: :laughing: 12345678910111213function* fibonacci () &#123; let a = 0 let b = 1 yield a yield b while (true) &#123; [a, b] = [b, a + b] yield b &#125;&#125;let gen = fibonacci() // Infinite fibonacci number generator!gen.next().value // Use this to get next fibonacci number Formula, Lookup Array…You can read the 3rd reference for more! :yum: References Fibonacci number - Wikipedia 性能优化：memoization 7 Surprising Things I Learned Writing a Fibonacci Generator in JavaScript","categories":[{"name":"自问","slug":"自问","permalink":"http://shawndai.cn/blog/categories/自问/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://shawndai.cn/blog/tags/算法/"},{"name":"递归","slug":"递归","permalink":"http://shawndai.cn/blog/tags/递归/"},{"name":"性能优化","slug":"性能优化","permalink":"http://shawndai.cn/blog/tags/性能优化/"}]},{"title":"What's the difference between let, const and var?","slug":"2016-07-18","date":"2016-07-17T16:00:00.000Z","updated":"2017-09-14T03:49:22.382Z","comments":true,"path":"posts/whats-the-difference-between-let-const-and-var/","link":"","permalink":"http://shawndai.cn/blog/posts/whats-the-difference-between-let-const-and-var/","excerpt":"varScopeAs we all know, there isn’t block-level scope but function-level scope in JavaScript. For example: 12345678910111213var scope = 'outer scope'&#123; var scope = 'inner scope' console.log(scope) // inner scope&#125;console.log(scope) // inner scopefunction foo() &#123; var scope = 'function scope'; console.log(scope) // function scope&#125;foo()console.log(scope) // inner scope","text":"varScopeAs we all know, there isn’t block-level scope but function-level scope in JavaScript. For example: 12345678910111213var scope = 'outer scope'&#123; var scope = 'inner scope' console.log(scope) // inner scope&#125;console.log(scope) // inner scopefunction foo() &#123; var scope = 'function scope'; console.log(scope) // function scope&#125;foo()console.log(scope) // inner scope HoistingMoreover, declaring a variable at anywhere is equivalent to delcaring it at the top (of the function or global) in JavaScript, which is called hoisting. For example: 1234567console.log(a) // undefinedvar a = 1;(function () &#123; if (!a) console.log(a) // undefined, since a has been hoisted var a = 2 console.log(a) // 2&#125;)() let and constscopeECMAScript 2015 (aka ES6) introduced two ways to declare block-level scope local variables: let and const. let‘s function is likes var, and const declares read-only value. 123456let scope = 'outer scope'&#123; let scope = 'inner scope' console.log(scope) // inner scope&#125;console.log(scope) // outer scope HoistingVariables declared by let and const will also be hoisted to the top of the blocks. But unlike var, referencing the variables declared by let and const before their declarations will result in a ReferenceError because of the TDZ (Temporal Dead Zone, the region of a program, where a variable or a parameter cannot be accessed until it’s initialized). The specification says: let and const declarations define variables that are scoped to the running execution context’s LexicalEnvironment. The variables are created when their containing Lexical Environment is instantiated but may not be accessed in any way until the variable’s LexicalBinding is evaluated. A variable defined by a LexicalBinding with an Initializer is assigned the value of its Initializer’s AssignmentExpression when the LexicalBinding is evaluated, not when the variable is created. If a LexicalBinding in a let declaration does not have an Initializer the variable is assigned the value undefined when the LexicalBinding is evaluated. Examples: 1234567891011121314151617181920212223242526272829let a = 1&#123; // ReferenceError // Because `let a` has been hoisted but cannot be referenced console.log(a) let a = 2&#125;// equivalent to: let b = undefined, so can be referenced from now onlet b// ReferenceError// Assignment happens when the LexicalBinding is evaluated// However, right-side c is hoisted and under TDZ now...let c = cfunction tdz (x = y, y) &#123; console.log(x, y)&#125;tdz(undefined, 1) // ReferenceError, y is not definedlet q = 1function tdz2 (p = q, q) &#123; console.log(p, q)&#125;tdz2(undefined, 2) // Still ReferenceError, q is not defined// Default parameters are evaluated in an intermediate scope// In which, p = q will resolve q in the intermediate scope,// but q cannot be referenced until it's initialized BTW, TDZ is not implemented in most transpilers (like babel, traceur), an issue. :cold_sweat: References JavaScript Scoping and Hoisting var hoisting - MDN let - MDN Temporal dead zone (TDZ) demystified ES6 Notes - Default value of parameters","categories":[{"name":"自问","slug":"自问","permalink":"http://shawndai.cn/blog/categories/自问/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://shawndai.cn/blog/tags/javascript/"},{"name":"ES6","slug":"ES6","permalink":"http://shawndai.cn/blog/tags/ES6/"}]},{"title":"What are multipart/form-data and application/x-www-form-urlencoded?","slug":"2016-07-17","date":"2016-07-16T16:00:00.000Z","updated":"2017-09-14T03:49:04.379Z","comments":true,"path":"posts/what-are-multipart-form-data-and-application-x-www-form-urlencoded/","link":"","permalink":"http://shawndai.cn/blog/posts/what-are-multipart-form-data-and-application-x-www-form-urlencoded/","excerpt":"Both of them are the optional values of enctype where the &lt;form&gt; element specifies the content type used to encode the form data set for submission to the server. There are three choices: application/x-www-form-urlencoded (default) multipart/form-data text/plain","text":"Both of them are the optional values of enctype where the &lt;form&gt; element specifies the content type used to encode the form data set for submission to the server. There are three choices: application/x-www-form-urlencoded (default) multipart/form-data text/plain application/x-www-form-urlencoded Just like a querystring: name=John+Smith&amp;age=27; Each character that cannot be expressed using the selected character encoding, replacing the character by a string like &amp;#xxxx; where xxxx means the Unicode code point of the character in base 10. (NCR); Replace 0x20 (space) the byte by +; Leave characters match /[\\*\\-\\.0-9A-Z_a-z]/ (alphanumeric) as is; Otherwise, replace the byte (non-alphanumeric) by %HH (must be two) where HH means the uppsercase ASCII hex digits representing the byte. multipart/form-dataTalk is cheap, show you the code: 12345&lt;form enctype='multipart/form-data' method='POST' action='test'&gt; &lt;input type='file' name='file' value='千本桜.txt'/&gt; &lt;input type='text' name='text' value='John Smith' /&gt; &lt;input type='submit' name='submit' value='Submit Button' /&gt;&lt;/form&gt; The corresponding HTTP request would like this: The boundary in the Content-Type works just like the &amp; in querystring, but its value shall never appear in the entries (key and value). The name in the Content-Disposition is the same as the entry’s name. text/plainDo not use. Payloads using the text/plain format are intended to be human readable. They are not reliably interpretable by computer, as the format is ambiguous (for example, there is no way to distinguish a literal newline in a value from the newline at the end of the value). Application If you have binary (non-alphanumeric) data (or a significantly sized payload) to transmit, use multipart/form-data. Otherwise, use application/x-www-form-urlencoded. BTW, if you are using ajax, there are more choices for you. Like application/json, application/xml… References application/x-www-form-urlencoded or multipart/form-data? Forms - W3C &amp;#x开头的是什么编码呢 Character Entity Reference Chart Returning Values from Forms: multipart/form-data","categories":[{"name":"自问","slug":"自问","permalink":"http://shawndai.cn/blog/categories/自问/"}],"tags":[{"name":"http","slug":"http","permalink":"http://shawndai.cn/blog/tags/http/"}]},{"title":"Differences between cookie, session and Web Storage?","slug":"2016-07-13","date":"2016-07-12T16:00:00.000Z","updated":"2017-09-14T03:48:33.486Z","comments":true,"path":"posts/differences-between-cookie-session-and-web-storage/","link":"","permalink":"http://shawndai.cn/blog/posts/differences-between-cookie-session-and-web-storage/","excerpt":"CookieHTTP is a stateless protocol, but there are many situations where we need to get stateful infomation…Cookies were designed for this to be a reliable mechanism for websibites to remember stateful information. A cookie is a small piece of data sent from a website and stored in the user’s web browser while the user is browsing.","text":"CookieHTTP is a stateless protocol, but there are many situations where we need to get stateful infomation…Cookies were designed for this to be a reliable mechanism for websibites to remember stateful information. A cookie is a small piece of data sent from a website and stored in the user’s web browser while the user is browsing. Expires &amp; Max-Age Expires defines a specific date and time when the user agent should delete the cookie, with the format Wdy, DD Mon YYYY HH:MM:SS GMT. If Expires defines a date in the past, the user agent will delete it right away. Max-Age defines the cookie’s expiration as an interval of seconds in the future relative to the time the browser received the cookie. Cookies without Expires and Max-Age will be set as session cookies, it will be deleted after the user closes their user agents (browser). Domain &amp; Path Domain and Path define the scope of the cookie. If not specified by the server, they default to the domain (not including sub domains) and path of the requested resource. Domain can only be set on the current resource’s top domain and its sub domains. Secure &amp; HttpOnly Secure and HttpOnly are flags indicating the behaviors the cookie should be enabled. Secure defines whether the cookie communication should be limited to encryted transmission (HTTPS), directing user agents to use cookies only via secure/encrypted connections. HttpOnly directs the user agent not to expose cookies through channels other than HTTP(S) requests. If enabled, the cookie cannot be accessed via client-side scripting languages (JavaScript), which can avoid XSS partly. LimitThe user agents should provide: at least 4096 bytes per cookie at least 50 cookies per domain at least 3000 cookies total HowAdd fields in HTTP header. Server :arrow_right: User Agent 1Set-Cookie: key=value[; Expires=date][; Max-Age=seconds][; Domain=domain][; Path=path][; Secure][; HttpOnly] User Agent :arrow_right: Server 1Cookie: key=value Third-Party CookieA web page may contain images or other components stored on servers in other domains (advertisements or something). Cookies that are set during retrieval of these components are called third-party cookies. These cookies can be used to track a user across multiple sites by advertsing companies (where they placed the advertising components). Cookies Theft &amp;&amp; Session Hijacking Network Eavesdropping (Man-in-the-Middle Attack) DNS Cache Poisoning (publishing false sub-domain) XSS (Cross-Site Scripting) CSRF (Cross-Site Request Forgery) Details in the future. :joy: SessionSessions are server-side files / data that contain user information. Sessions have a unique ID that maps them to specific users. This ID can be passed in the URL or saved into a session cookie. Session ID A session token is a unique identifier that is generated and sent from a server to a client to identify the current interaction session. The client usually stores and sends the token as an HTTP cookie and/or sends it as a parameter in GET or POST queries. The reason to use session tokens is that the client only has to handle the identifier—all session data is stored on the server (usually in a database, to which the client does not have direct access) linked to that identifier. Web StorageThe Web Storage API provides mechanisms by which browsers can store key/value pairs, in a much more intuitive fashion than using cookies. sessionStorage maintains a separate storage area for each given origin that’s available for the duration of the page session (as long as the browser is open, including page reloads and restores) localStorage does the same thing, but persists even when the browser is closed and reopened. Usage1234567window.addEventListener('storage', (e) =&gt; console.log(e))localStorage.setItem('local', 1)localStorage.getItem('local') // 1localStorage.removeItem('local')localStorage.getItem('local') // nulllocalStorage.clear() // remove all items Differences Cookie Session localStorage sessionStorage Where Client Server Client Client How HTTP Header / JS Session ID - - API document.cookie Depend on server Web Storage API Web Storage API Size &gt;= 4KB no limit (Server) Vary between browsers Expire expires &amp; max-age Page duration Forever (removeItem / clear) Page duration References Differences between cookies and sessions? What is the difference between localStorage, sessionStorage, session and cookies? HTTP cookie - Wikipedia :bangbang: HTTP State Management Mechanism - Wikipedia Session (computer science) - Wikipedia Session ID - Wikipedia Web_storage - Wikipedia Web Storage Support Test","categories":[{"name":"自问","slug":"自问","permalink":"http://shawndai.cn/blog/categories/自问/"}],"tags":[{"name":"http","slug":"http","permalink":"http://shawndai.cn/blog/tags/http/"},{"name":"cookie","slug":"cookie","permalink":"http://shawndai.cn/blog/tags/cookie/"}]},{"title":"What's the difference between async and defer?","slug":"2016-07-12","date":"2016-07-11T16:00:00.000Z","updated":"2017-09-14T03:48:10.611Z","comments":true,"path":"posts/whats-the-difference-between-async-and-defer/","link":"","permalink":"http://shawndai.cn/blog/posts/whats-the-difference-between-async-and-defer/","excerpt":"The async and defer are boolean attributes introduced in HTML5 of &lt;script&gt;. Behaviorneither1&lt;script type=\"text/javascript\" src=\"where.js\"&gt;&lt;/script&gt; Once the HTML parser meets a &lt;script&gt;, the parser will stop parsing HTML and send a request to get the file (if it’s external). Then, the JavaScript engine will execute the script. After the script’s execution finished, the parser will continue parsing the HTML.","text":"The async and defer are boolean attributes introduced in HTML5 of &lt;script&gt;. Behaviorneither1&lt;script type=\"text/javascript\" src=\"where.js\"&gt;&lt;/script&gt; Once the HTML parser meets a &lt;script&gt;, the parser will stop parsing HTML and send a request to get the file (if it’s external). Then, the JavaScript engine will execute the script. After the script’s execution finished, the parser will continue parsing the HTML. async1&lt;script type=\"text/javascript\" src=\"where.js\" async&gt;&lt;/script&gt; Once the HTML parser meets a &lt;script async&gt;, the parser won’t stop and the browser will send a request to download the script parallelly. Once the download finishes, the parser will stop parsing HTML if it’s still parsing, and the JavaScript engine will excute the script. After the script’s execution finished, the parser will continue parsing the HTML if there are contents to be parsed. A typical example, Google Analytics. BTW, the execution order of async scripts is arbitrary. Once it’s downloaded, it begins to execute. So watch out the location it’s placed. defer1&lt;script type=\"text/javascript\" src=\"where.js\" defer&gt;&lt;/script&gt; Once the HTML parser meets a &lt;script defer&gt;, the parser won’t stop and the browser will send a request to download the script parallelly. Even the download finishes, the parser will continue parsing the HTML. After the parser completes parsing the HTML, the JavaScript engine begin to execute the deferred script. BTW, the deferred scritps are guaranteed to execute in the order they appear in the document. BothAccording to the specification: The defer attribute may be specified even if the async attribute is specified, to cause legacy Web browsers that only support defer (and not async) to fall back to the defer behavior instead of the synchronous blocking behavior that is the default. UsageFrom my perspective: The script that do not involve DOM operations and do not rely on other scripts should use async. The script that contains DOM operations or relies on other scripts upon should use defer. Small scripts (and relied by async scripts) should just use inline script (and placed before async scripts reling them), which avoid a extra RTT and won’t influence the size of HTML too much. Compatibility &lt;= IE9, scripts with defer‘s execution order is not guaranteed. link References async vs defer attributes A picture script - MDN","categories":[{"name":"自问","slug":"自问","permalink":"http://shawndai.cn/blog/categories/自问/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://shawndai.cn/blog/tags/javascript/"},{"name":"html","slug":"html","permalink":"http://shawndai.cn/blog/tags/html/"},{"name":"browser","slug":"browser","permalink":"http://shawndai.cn/blog/tags/browser/"}]},{"title":"What's Backus-Naur Form (BNF)?","slug":"2016-07-05","date":"2016-07-04T16:00:00.000Z","updated":"2017-09-14T03:47:55.333Z","comments":true,"path":"posts/whats-backus-naur-form/","link":"","permalink":"http://shawndai.cn/blog/posts/whats-backus-naur-form/","excerpt":"Quoted definition from wikipedia: In computer science, BNF (Backus Normal Form or Backus–Naur Form) is one of the two main notation techniques for context-free grammars, often used to describe the syntax of languages used in computing, such as computer programming languages, document formats, instruction sets and communication protocols. A BNF specification is a set of derivation rules, written as: 1&lt;symbol&gt; ::= __expression__","text":"Quoted definition from wikipedia: In computer science, BNF (Backus Normal Form or Backus–Naur Form) is one of the two main notation techniques for context-free grammars, often used to describe the syntax of languages used in computing, such as computer programming languages, document formats, instruction sets and communication protocols. A BNF specification is a set of derivation rules, written as: 1&lt;symbol&gt; ::= __expression__ where &lt;symbol&gt; is a nonterminal, and __expression__ consists of one or more sequences of symbols seperated by |, indicating a choice, the whole being a possible substitution for the &lt;symbol&gt;. Symbols that never appear on a left side are terminals, and symbols appear on the left are nonterminals always enclosed between the pair &lt;&gt;. And what’s more, ::= means that the symbol on the left must be replaced with the expression on the right. There are many variants and extensions of BNF, generally either for the sake of simplicity and succinctness, or to adapt it to a specific application. Like ABNF (Augmented), EBNF (Extended). ABNF: based on BNF but consisting of its own syntax and derivation rules, often serves as the definition languages for IETF communications protocols. Defined in RFC 5234. RFC 7404 updates it. EBNF: based on BNF but provides extra function like concatenation, optional, repetition, grouping…Any grammar defined in EBNF can also be represented in BNF, but representations in the latter are generally lengthier. For example: 123&lt;number&gt; ::= &lt;digit&gt; | &lt;number&gt; &lt;digit&gt;number = &#123;digit&#125; digit CSS Definition SyntaxW3C’s CSS property value definition syntax is based on the concept of BNF, but with some differences. Recently I’ve translated an article about this. An example of line-height property: 1&lt;'line-height'&gt; ::= normal | &lt;number&gt; | &lt;length&gt; | &lt;percentage&gt; | inherit where normal and inherit are keyword values, and &lt;number&gt;, &lt;length&gt;, &lt;percentage&gt; are basic data types. 123&lt;number&gt; ::= &#123;num&#125;&lt;percentage&gt; ::= &#123;num&#125;%&lt;num&gt; ::= [+-]?([0-9]+|[0-9]*\\.[0-9]+)(e[+-]?[0-9]+)? Reference: line-height, Tokenization","categories":[{"name":"自问","slug":"自问","permalink":"http://shawndai.cn/blog/categories/自问/"}],"tags":[{"name":"编译原理","slug":"编译原理","permalink":"http://shawndai.cn/blog/tags/编译原理/"}]},{"title":"What's the date time string format in JavaScript?","slug":"2016-07-04","date":"2016-07-03T16:00:00.000Z","updated":"2017-09-14T03:45:00.506Z","comments":true,"path":"posts/whats-the-date-time-string-format-in-javascript/","link":"","permalink":"http://shawndai.cn/blog/posts/whats-the-date-time-string-format-in-javascript/","excerpt":"Date time string can be used as the argument of Date.parse method or the Date constructor in JavaScript. According to the specification of Date Time String Format: ECMAScript defines a string interchange format for date-times based upon a simplification of the ISO 8601 Extended Format. The format is as follows: YYYY-MM-DDTHH:mm:ss.sssZ.","text":"Date time string can be used as the argument of Date.parse method or the Date constructor in JavaScript. According to the specification of Date Time String Format: ECMAScript defines a string interchange format for date-times based upon a simplification of the ISO 8601 Extended Format. The format is as follows: YYYY-MM-DDTHH:mm:ss.sssZ. The table of all fields’ meanings: YYYY MM DD HH mm ss sss Z - T : . Year Month Day Hour Minute Second Millisecond TimeZoneOffset Literally 0000-9999 01-12 01-31 00-24 00-59 00-59 000-999 Z / ±HH:mm - Note: If the time is in UTC, just use “Z” directly for Z. “Z” is the zone designator for the zero UTC offset. Offset from UTC are write in the format “±HH:mm”. For example, China’s Z should be +08:00. There is a picture contains all UTC time zone offsets. 本当に面白い！ GMTGMT means the Greenwich Mean Time, formerly used as the international civil time standard, which is superseded in that function by Coordinated Universal Time, because of earth’s uneven speed in its elliptical orbit and its axial tilt. UTUT, Universal Time, is a time standard based on Earth’s rotation. It’s a modern continuation of GMT. There are several versions of it, like UTC, UT1… All UT except for UTC are based on Earth’s rotation relative to distant celestial objects, but with a scaling factor and other adjustments to make them closer to solar time. UTC is based on International Atomic Time, with leap seconds added to keep it within 0.9 second of UT1. UTCUTC, Coordinated Universal Time, is the primary time standard by which the world regulates clock and time. It is closely related to GMT. For most purposes, UTC is considered interchangeable with GMT, but GMT is no longer precisely defined by the scientific community. ISO 8601ISO 8601 is an international standard covering the exchange of date and time-related data, issued by ISO. The purpose of this is to provide an unambiguous and well-defined method of representing dates and times. (It shocked me that the standard should charge…=&gt;link) Date String in ActionThere are the results of all Date‘s toString methods in JavaScript: (I’m in China now.) Method Result toString Mon Jul 04 2016 22:54:38 GMT+0800 (中国标准时间) toJSON 2016-07-04T14:54:38.766Z toDateString Mon Jul 04 2016 toTimeString 22:54:38 GMT+0800 (中国标准时间) toGMTString Mon, 04 Jul 2016 14:54:38 GMT toUTCString Mon, 04 Jul 2016 14:54:38 GMT toISOString 2016-07-04T14:54:38.766Z toLocaleString 2016/7/4 下午10:54:38 toLocaleDateString 2016/7/4 toLocaleTimeString 下午10:54:38 Now I know that GMT and UTC are time standards while ISO 8601 provides the representation form of time. A LibraryMoment.js, a library that parses, validates, manipulates, and displays dates in JavaScript. This website is using this library now. Example: 12moment('20160704', 'YYYYMMDD').format('MMMM D, YYYY');// July 4, 2016, exactly the title of this website.","categories":[{"name":"自问","slug":"自问","permalink":"http://shawndai.cn/blog/categories/自问/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://shawndai.cn/blog/tags/javascript/"}]},{"title":"What does error like EPERM, ENOENT means in Node.js?","slug":"2016-06-27","date":"2016-06-26T16:00:00.000Z","updated":"2017-09-14T03:44:21.549Z","comments":true,"path":"posts/what-does-error-like-eperm-means-in-nodejs/","link":"","permalink":"http://shawndai.cn/blog/posts/what-does-error-like-eperm-means-in-nodejs/","excerpt":"","text":"Things like EPERM, EONENT are the error names(codes) which represent different system call error. For example: EPERM: Operation not permitted. ENOENT: No such file or directory. Of course, there are not only two of them. I searched Node.js’s API and find an exhausitive list which shows all those error codes and their meanings. What’s more, there is a link which refers to the &lt;errno.h&gt; header file in Linux, which says: All the error names specified by POSIX.1 must have distinct values, with the exception of EAGAIN and EWOULDBLOCK, which may be the same. I found the corresponding POSIX.1 specification here, and this is the latest version of &lt;errno.h&gt;. As it says, it’s an extension of ISO C standard, and Node.js is mainly based on C, so there is no wonder that Node.js will use those strange names. Log Errors EasierWhen we use those APIs in Node.js which handle the system call and error happens, those methods will return an error as the first parameter of the callback. It’s not easy for us to remember each error and corresponding description, so our error message would be hard to read. Fortunately, there is a library node-errno that can help us with that. You can pass the errno to it and it will return a description about it. So now we have more friendly error message~","categories":[{"name":"自问","slug":"自问","permalink":"http://shawndai.cn/blog/categories/自问/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://shawndai.cn/blog/tags/linux/"},{"name":"nodejs","slug":"nodejs","permalink":"http://shawndai.cn/blog/tags/nodejs/"}]}]}